name: Cleanup untagged GHCR packages (multi-arch safe)

on:
  workflow_dispatch:

jobs:
  cleanup:
    runs-on: ubuntu-latest
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      PACKAGE_OWNER: medium1992
      PACKAGE_NAME: mihomo-fakeip-ros
      DELETE_UNTAGGED: "false" # true ‚Äî —Ä–µ–∞–ª—å–Ω–æ —É–¥–∞–ª—è–µ—Ç

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install jq and crane
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
          # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º crane
          curl -sL https://github.com/google/go-containerregistry/releases/download/v0.20.2/go-containerregistry_Linux_x86_64.tar.gz | sudo tar -C /usr/local/bin -xz crane
          chmod +x /usr/local/bin/crane
          crane version || { echo "Crane failed to install"; exit 1; }

      - name: Log in to GHCR with crane
        run: echo "${GITHUB_TOKEN}" | crane auth login ghcr.io -u ${PACKAGE_OWNER} --password-stdin

      - name: Analyze GHCR packages
        run: |
          set -e

          echo "Fetching package versions for ${PACKAGE_OWNER}/${PACKAGE_NAME}..."
          page=1
          packages_json="[]"
          last_first_id=""
          while true; do
            echo "Fetching page $page..."
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º curl –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –∏ –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤
            response=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/users/$PACKAGE_OWNER/packages/container/$PACKAGE_NAME/versions?per_page=100&page=$page" \
              -D headers.txt)
            chunk="$response"
            # –î–µ–±–∞–≥: –≤—ã–≤–æ–¥–∏–º –ø–µ—Ä–≤—ã–µ 50 —Å–∏–º–≤–æ–ª–æ–≤ —á–∞–Ω–∫–∞
            echo "Page $page raw chunk: ${chunk:0:50}..."
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º HTTP-—Å—Ç–∞—Ç—É—Å
            http_status=$(head -n 1 headers.txt | cut -d' ' -f2)
            if [[ "$http_status" != "200" ]]; then
              echo "Error: HTTP status $http_status on page $page"
              cat headers.txt
              exit 1
            fi
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø—É—Å—Ç–æ–π –ª–∏ —á–∞–Ω–∫
            if [[ "$chunk" == "[]" ]]; then
              echo "No more versions on page $page (empty response)"
              break
            fi
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–µ—Ä—Å–∏–π
            chunk_count=$(echo "$chunk" | jq length)
            echo "Page $page: $chunk_count versions"
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–≤—É—é –≤–µ—Ä—Å–∏—é –≤ —á–∞–Ω–∫–µ, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è
            first_id=$(echo "$chunk" | jq -r '.[0].id // ""')
            if [[ -n "$last_first_id" && "$first_id" == "$last_first_id" ]]; then
              echo "Page $page has same data as previous (ID: $first_id), stopping"
              break
            fi
            last_first_id="$first_id"
            # –û–±—ä–µ–¥–∏–Ω—è–µ–º —á–∞–Ω–∫
            if [[ "$packages_json" == "[]" ]]; then
              packages_json="$chunk"
            else
              packages_json=$(jq -s '.[0] + .[1]' <(echo "$packages_json") <(echo "$chunk"))
            fi
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫ Link –Ω–∞ –Ω–∞–ª–∏—á–∏–µ —Å–ª–µ–¥—É—é—â–µ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã
            has_next=$(grep -E 'rel="next"' headers.txt || true)
            if [[ -z "$has_next" ]]; then
              echo "No 'next' link in headers on page $page, stopping"
              break
            fi
            ((page++))
            # –û–≥—Ä–∞–Ω–∏—á–∏–º –¥–æ 10 —Å—Ç—Ä–∞–Ω–∏—Ü –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
            if [[ $page -gt 10 ]]; then
              echo "Reached max page limit (10)"
              break
            fi
          done

          total=$(echo "$packages_json" | jq length)
          echo "Total versions found: $total (pages processed: $((page-1)))"
          echo ""

          declare -A protected_digests
          declare -A child_digests
          declare -A manifest_ids

          echo "=== üè∑Ô∏è Tagged manifests ==="
          for row in $(echo "$packages_json" | jq -r '.[] | select(.metadata.container.tags | length > 0) | @base64'); do
            _jq() { echo "$row" | base64 --decode | jq -r "$1"; }

            id=$(_jq '.id')
            digest=$(_jq '.name')
            tags=$(_jq '.metadata.container.tags | join(", ")')
            created=$(_jq '.created_at')
            mediaType=$(_jq '.metadata.container.manifest.mediaType // "unknown"')

            manifest_ids[$id]=1
            protected_digests[$digest]=1

            # –ò–∑–≤–ª–µ–∫–∞–µ–º child digests —Å –ø–æ–º–æ—â—å—é crane
            echo "  üì¶ Inspecting manifest for tags: [$tags]"
            for tag in $(_jq '.metadata.container.tags[]' | sort -u); do
              manifest_json=$(timeout 10s crane manifest ghcr.io/${PACKAGE_OWNER}/${PACKAGE_NAME}:${tag} 2>/dev/null || echo "{}")
              sub_digests=$(echo "$manifest_json" | jq -r '.manifests[].digest // empty')
              for sd in $sub_digests; do
                if [[ -n "$sd" ]]; then
                  child_digests[$sd]=1
                  protected_digests[$sd]=1
                  echo "    ‚Üí Protected child digest: $sd"
                fi
              done
            done

            echo "- ID: $id | Digest: $digest | Tags: [$tags] | Created: $created | Type: manifest ($mediaType)"
          done

          echo ""
          echo "Protected child digests count: ${#child_digests[@]}"
          echo ""

          echo "=== üß© Untagged images ==="
          untagged_ids=($(echo "$packages_json" | jq -r '.[] | select(.metadata.container.tags | length == 0) | .id'))

          safe_untagged_ids=()

          for id in "${untagged_ids[@]}"; do
            data=$(timeout 10s curl -s -H "Authorization: Bearer $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/users/$PACKAGE_OWNER/packages/container/$PACKAGE_NAME/versions/$id" || echo "{}")
            digest=$(echo "$data" | jq -r '.name // "unknown"')
            created=$(echo "$data" | jq -r '.created_at // "unknown"')
            mediaType=$(echo "$data" | jq -r '.metadata.container.manifest.mediaType // "unknown"')

            if [[ "$digest" == "unknown" ]]; then
              echo "Error: Failed to fetch data for ID $id"
              continue
            fi

            if [[ -n "${child_digests[$digest]}" || -n "${protected_digests[$digest]}" ]]; then
              echo "- ID: $id | Digest: $digest | Created: $created | Type: $mediaType ‚Üí üõ° –ø—Ä–æ–ø—É—â–µ–Ω (child or referenced)"
            else
              echo "- ID: $id | Digest: $digest | Created: $created | Type: $mediaType ‚Üí üßπ –∫–∞–Ω–¥–∏–¥–∞—Ç –Ω–∞ —É–¥–∞–ª–µ–Ω–∏–µ"
              safe_untagged_ids+=("$id")
            fi
          done

          echo ""
          if [[ "${DELETE_UNTAGGED}" == "true" && ${#safe_untagged_ids[@]} -gt 0 ]]; then
            echo "‚ö†Ô∏è Deleting ${#safe_untagged_ids[@]} truly untagged image versions..."
            for id in "${safe_untagged_ids[@]}"; do
              echo "Deleting version ID: $id ..."
              curl -s -X DELETE -H "Authorization: Bearer $GITHUB_TOKEN" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/users/$PACKAGE_OWNER/packages/container/$PACKAGE_NAME/versions/$id" \
                && echo "‚úÖ Deleted $id" \
                || echo "‚ùå Failed to delete $id"
            done
          else
            echo "Dry-run mode (no deletions)."
            echo "Safe untagged image IDs found: ${#safe_untagged_ids[@]}"
          fi